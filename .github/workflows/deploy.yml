name: Deploy Portfolio to ECS

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: somdip-portfolio
  ECS_SERVICE: somdip-portfolio-service
  ECS_CLUSTER: somdip-dev-cluster
  ECS_TASK_DEFINITION: somdip-portfolio
  CONTAINER_NAME: portfolio

jobs:
  deploy:
    name: Deploy to ECS
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2

    - name: Run tests
      run: mvn clean test

    - name: Build with Maven
      run: mvn clean package -DskipTests

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "Building Docker image..."
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "Pushing image with both tags..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "‚úÖ Image pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

    - name: Download current task definition template
      run: |
        # Get a base task definition to work with
        aws ecs describe-task-definition \
          --task-definition $ECS_TASK_DEFINITION \
          --query taskDefinition > task-definition-base.json
        
        # Clean it up for registration
        cat task-definition-base.json | jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)' > task-definition-clean.json

    - name: Create task definition with complete environment
      env:
        SENDGRID_API_KEY: ${{ secrets.SENDGRID_API_KEY }}
      run: |
        echo "Creating task definition with complete environment configuration..."
        
        # Create task definition with all required environment variables
        cat task-definition-clean.json | jq --arg IMAGE "${{ steps.build-image.outputs.image }}" --arg SENDGRID_KEY "$SENDGRID_API_KEY" '
        .containerDefinitions[0].image = $IMAGE |
        .containerDefinitions[0].environment = [
          {"name": "HR_DEMO_HEALTH_STRATEGY", "value": "actuator-health"},
          {"name": "HR_DEMO_EXTERNAL_URL", "value": "https://demos.somdip.dev"},
          {"name": "HR_DEMO_EMBED_URL", "value": "http://somdip-dev-alb-856223136.us-east-1.elb.amazonaws.com:8081"},
          {"name": "SPRING_PROFILES_ACTIVE", "value": "prod"},
          {"name": "SPRING_MAIL_ENABLED", "value": "true"},
          {"name": "SMTP_HOST", "value": "smtp.sendgrid.net"},
          {"name": "SMTP_PORT", "value": "587"},
          {"name": "SENDGRID_USERNAME", "value": "apikey"},
          {"name": "SENDGRID_API_KEY", "value": $SENDGRID_KEY}
        ]' > task-definition-final.json
        
        echo "‚úÖ Task definition created with SendGrid configuration"
        echo "Environment variables configured:"
        cat task-definition-final.json | jq '.containerDefinitions[0].environment[] | select(.name != "SENDGRID_API_KEY") | "\(.name)=\(.value)"' -r
        echo "SENDGRID_API_KEY=***HIDDEN***"

    - name: Register new task definition
      id: register-task-def
      run: |
        echo "Registering new task definition..."
        NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
          --cli-input-json file://task-definition-final.json \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        
        echo "new-task-def-arn=$NEW_TASK_DEF_ARN" >> $GITHUB_OUTPUT
        echo "‚úÖ New task definition registered: $NEW_TASK_DEF_ARN"
        
        # Verify the new task definition
        echo "Verifying new task definition configuration:"
        aws ecs describe-task-definition \
          --task-definition $NEW_TASK_DEF_ARN \
          --query 'taskDefinition.containerDefinitions[0].[image,environment[?name==`SPRING_MAIL_ENABLED`]]' \
          --output text

    - name: Update ECS service
      run: |
        echo "Updating ECS service with new task definition..."
        
        aws ecs update-service \
          --cluster $ECS_CLUSTER \
          --service $ECS_SERVICE \
          --task-definition ${{ steps.register-task-def.outputs.new-task-def-arn }} \
          --desired-count 2 \
          --force-new-deployment \
          --deployment-configuration '{
            "minimumHealthyPercent": 50,
            "maximumPercent": 200,
            "deploymentCircuitBreaker": {
              "enable": false,
              "rollback": false
            }
          }' \
          --query 'service.[serviceName,taskDefinition,desiredCount]' \
          --output table
        
        echo "‚úÖ Service update initiated"

    - name: Monitor deployment progress
      run: |
        echo "Monitoring deployment progress (up to 10 minutes)..."
        
        for i in {1..30}; do  # 10 minutes max
          echo "Check $i/30:"
          
          # Get deployment status
          DEPLOY_STATUS=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --query 'services[0].deployments[0].status' \
            --output text)
          
          RUNNING_COUNT=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --query 'services[0].runningCount' \
            --output text)
          
          CURRENT_TASK_DEF=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --query 'services[0].taskDefinition' \
            --output text)
          
          echo "  Status: $DEPLOY_STATUS"
          echo "  Running: $RUNNING_COUNT/2"
          echo "  Task Def: $(basename $CURRENT_TASK_DEF)"
          
          # Check if using new task definition and all tasks running
          if [ "$DEPLOY_STATUS" = "STABLE" ] && [ "$RUNNING_COUNT" = "2" ]; then
            echo "‚úÖ Deployment completed successfully!"
            break
          fi
          
          # Check if deployment failed
          if [ "$DEPLOY_STATUS" = "FAILED" ]; then
            echo "‚ùå Deployment failed!"
            aws ecs describe-services \
              --cluster $ECS_CLUSTER \
              --service $ECS_SERVICE \
              --query 'services[0].events[:5].[createdAt,message]' \
              --output table
            exit 1
          fi
          
          sleep 20
        done

    - name: Verify final deployment
      run: |
        echo "Final deployment verification..."
        
        # Get current service details
        echo "Service details:"
        aws ecs describe-services \
          --cluster $ECS_CLUSTER \
          --service $ECS_SERVICE \
          --query 'services[0].[serviceName,taskDefinition,runningCount,desiredCount,deployments[0].status]' \
          --output table
        
        # Get running tasks and their images
        echo "Running tasks:"
        TASK_ARNS=$(aws ecs list-tasks \
          --cluster $ECS_CLUSTER \
          --service-name $ECS_SERVICE \
          --query 'taskArns' \
          --output text)
        
        if [ ! -z "$TASK_ARNS" ]; then
          aws ecs describe-tasks \
            --cluster $ECS_CLUSTER \
            --tasks $TASK_ARNS \
            --query 'tasks[*].[containers[0].image,createdAt,lastStatus]' \
            --output table
        fi

    - name: Test endpoints
      run: |
        echo "Testing application endpoints..."
        sleep 30  # Wait for ALB to register new targets
        
        # Test main site
        echo "Testing main site:"
        HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "Host: somdip.dev" http://somdip-dev-alb-856223136.us-east-1.elb.amazonaws.com)
        echo "  HTTP Status: $HTTP_STATUS"
        
        # Test health endpoint
        echo "Testing health endpoint:"
        HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "Host: somdip.dev" http://somdip-dev-alb-856223136.us-east-1.elb.amazonaws.com/actuator/health)
        echo "  Health Status: $HEALTH_STATUS"
        
        if [ "$HTTP_STATUS" = "200" ] && [ "$HEALTH_STATUS" = "200" ]; then
          echo "‚úÖ All endpoints responding correctly!"
        else
          echo "‚ö†Ô∏è  Some endpoints may need more time"
        fi

    - name: Deployment summary
      run: |
        echo ""
        echo "üöÄ Portfolio Deployment Summary"
        echo "==============================="
        echo "‚úÖ Image built and pushed: ${{ steps.build-image.outputs.image }}"
        echo "‚úÖ Task definition created: ${{ steps.register-task-def.outputs.new-task-def-arn }}"
        echo "‚úÖ SendGrid mail configuration: ENABLED"
        echo "‚úÖ Service updated successfully"
        echo ""
        echo "üîó Test your changes:"
        echo "   Production: https://somdip.dev"
        echo "   Health Check: https://somdip.dev/actuator/health"
        echo ""
        echo "üìß SendGrid Integration:"
        echo "   Status: ACTIVE"
        echo "   Monitor: https://app.sendgrid.com/email_activity"
        echo ""
        echo "üîç Clear browser cache (Ctrl+F5) to see the latest changes!"

    - name: Cleanup temporary files
      run: |
        rm -f task-definition-*.json
        echo "‚úÖ Cleanup complete"
