name: Deploy Portfolio to ECS (Fixed)

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: somdip-portfolio
  ECS_SERVICE: somdip-portfolio-service
  ECS_CLUSTER: somdip-dev-cluster
  ECS_TASK_DEFINITION: somdip-portfolio
  CONTAINER_NAME: portfolio

jobs:
  deploy:
    name: Deploy to ECS
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2

    - name: Run tests
      run: mvn clean test

    - name: Build with Maven
      run: mvn clean package -DskipTests

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "Building Docker image..."
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "Pushing image with both tags..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "‚úÖ Image pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

    - name: Download and clean current task definition
      run: |
        echo "Downloading current task definition..."
        aws ecs describe-task-definition \
          --task-definition $ECS_TASK_DEFINITION \
          --query taskDefinition > task-definition-raw.json
        
        # Clean up the task definition (remove read-only fields)
        cat task-definition-raw.json | jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)' > task-definition.json
        
        echo "Current image in task definition:"
        cat task-definition.json | jq -r '.containerDefinitions[0].image'

    - name: Fill in the new image ID in the Amazon ECS task definition
      id: task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: task-definition.json
        container-name: ${{ env.CONTAINER_NAME }}
        image: ${{ steps.build-image.outputs.image }}

    - name: Register new task definition
      id: register-task-def
      run: |
        echo "Registering new task definition..."
        NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
          --cli-input-json file://${{ steps.task-def.outputs.task-definition }} \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        
        echo "new-task-def-arn=$NEW_TASK_DEF_ARN" >> $GITHUB_OUTPUT
        echo "‚úÖ New task definition registered: $NEW_TASK_DEF_ARN"
        
        # Verify the new task definition has the correct image
        echo "Verifying new task definition image:"
        aws ecs describe-task-definition \
          --task-definition $NEW_TASK_DEF_ARN \
          --query 'taskDefinition.containerDefinitions[0].image' \
          --output text

    - name: Update ECS service with new task definition
      run: |
        echo "Updating ECS service with new task definition..."
        echo "Before update - Current service status:"
        aws ecs describe-services \
          --cluster $ECS_CLUSTER \
          --service $ECS_SERVICE \
          --query 'services[0].[serviceName,taskDefinition,runningCount,desiredCount]' \
          --output table
        
        echo "Updating service..."
        aws ecs update-service \
          --cluster $ECS_CLUSTER \
          --service $ECS_SERVICE \
          --task-definition ${{ steps.register-task-def.outputs.new-task-def-arn }} \
          --desired-count 2 \
          --force-new-deployment \
          --deployment-configuration '{
            "minimumHealthyPercent": 50,
            "maximumPercent": 200,
            "deploymentCircuitBreaker": {
              "enable": true,
              "rollback": true
            }
          }' \
          --query 'service.[serviceName,taskDefinition,desiredCount,runningCount]' \
          --output table
        
        echo "‚úÖ Service update initiated"

    - name: Monitor deployment progress
      run: |
        echo "Monitoring deployment progress (up to 8 minutes)..."
        
        for i in {1..48}; do  # 8 minutes max
          echo "Check $i/48:"
          
          # Get deployment status
          DEPLOY_STATUS=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --query 'services[0].deployments[0].status' \
            --output text)
          
          RUNNING_COUNT=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --query 'services[0].runningCount' \
            --output text)
          
          CURRENT_TASK_DEF=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --query 'services[0].taskDefinition' \
            --output text)
          
          echo "  Status: $DEPLOY_STATUS"
          echo "  Running: $RUNNING_COUNT/2"
          echo "  Task Def: $CURRENT_TASK_DEF"
          
          # Check if using new task definition and all tasks running
          if [ "$DEPLOY_STATUS" = "STABLE" ] && [ "$RUNNING_COUNT" = "2" ] && [[ "$CURRENT_TASK_DEF" == *"${{ steps.register-task-def.outputs.new-task-def-arn }}"* ]]; then
            echo "‚úÖ Deployment completed successfully!"
            break
          fi
          
          # Check if deployment failed
          if [ "$DEPLOY_STATUS" = "FAILED" ]; then
            echo "‚ùå Deployment failed!"
            aws ecs describe-services \
              --cluster $ECS_CLUSTER \
              --service $ECS_SERVICE \
              --query 'services[0].events[:3].[createdAt,message]' \
              --output table
            exit 1
          fi
          
          sleep 10
        done

    - name: Verify final deployment
      run: |
        echo "Final deployment verification..."
        
        # Get current service details
        echo "Service details:"
        aws ecs describe-services \
          --cluster $ECS_CLUSTER \
          --service $ECS_SERVICE \
          --query 'services[0].[serviceName,taskDefinition,runningCount,desiredCount,deployments[0].status]' \
          --output table
        
        # Get running tasks and their images
        echo "Running tasks:"
        TASK_ARNS=$(aws ecs list-tasks \
          --cluster $ECS_CLUSTER \
          --service-name $ECS_SERVICE \
          --query 'taskArns' \
          --output text)
        
        if [ ! -z "$TASK_ARNS" ]; then
          aws ecs describe-tasks \
            --cluster $ECS_CLUSTER \
            --tasks $TASK_ARNS \
            --query 'tasks[*].[taskArn,containers[0].image,createdAt,lastStatus]' \
            --output table
          
          # Verify all tasks are using the new image
          NEW_IMAGE_COUNT=$(aws ecs describe-tasks \
            --cluster $ECS_CLUSTER \
            --tasks $TASK_ARNS \
            --query "length(tasks[?contains(containers[0].image, '${{ github.sha }}')])" \
            --output text)
          
          echo "Tasks using new image (${{ github.sha }}): $NEW_IMAGE_COUNT/2"
          
          if [ "$NEW_IMAGE_COUNT" = "2" ]; then
            echo "‚úÖ All tasks are using the new image!"
          else
            echo "‚ö†Ô∏è  Some tasks may still be using old image"
          fi
        fi

    - name: Test endpoint
      run: |
        echo "Testing endpoint..."
        sleep 30  # Wait for ALB to register new targets
        
        # Test multiple times
        for i in {1..3}; do
          echo "Test $i/3:"
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "Host: somdip.dev" http://somdip-dev-alb-856223136.us-east-1.elb.amazonaws.com)
          echo "  HTTP Status: $HTTP_STATUS"
          
          if [ "$HTTP_STATUS" = "200" ]; then
            echo "  ‚úÖ Site responding correctly"
          else
            echo "  ‚ö†Ô∏è  Unexpected status: $HTTP_STATUS"
          fi
          sleep 10
        done

    - name: Final summary
      run: |
        echo ""
        echo "üöÄ Portfolio Deployment Summary"
        echo "==============================="
        echo "‚úÖ Image built and pushed: ${{ steps.build-image.outputs.image }}"
        echo "‚úÖ Task definition created: ${{ steps.register-task-def.outputs.new-task-def-arn }}"
        echo "‚úÖ Service updated successfully"
        echo ""
        echo "üîó Test your changes:"
        echo "   Production: https://somdip.dev"
        echo "   Direct ALB: http://somdip-dev-alb-856223136.us-east-1.elb.amazonaws.com"
        echo ""
        echo "üîç Clear browser cache and test your changes!"

    - name: Cleanup on failure
      if: failure()
      run: |
        echo "‚ùå Deployment failed. Debug information:"
        
        echo "Service status:"
        aws ecs describe-services \
          --cluster $ECS_CLUSTER \
          --service $ECS_SERVICE \
          --query 'services[0].[serviceName,taskDefinition,runningCount,desiredCount]' \
          --output table
        
        echo "Recent events:"
        aws ecs describe-services \
          --cluster $ECS_CLUSTER \
          --service $ECS_SERVICE \
          --query 'services[0].events[:5].[createdAt,message]' \
          --output table
