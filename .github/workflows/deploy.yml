name: Deploy Portfolio to ECS (Fixed)

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: somdip-portfolio
  ECS_SERVICE: somdip-portfolio-service
  ECS_CLUSTER: somdip-dev-cluster
  ECS_TASK_DEFINITION: somdip-portfolio
  CONTAINER_NAME: portfolio
  LOG_GROUP: /ecs/somdip-portfolio  # Fixed log group name

jobs:
  deploy:
    name: Deploy to ECS
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2

    - name: Run tests
      run: mvn clean test

    - name: Build with Maven
      run: mvn clean package -DskipTests

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "Building Docker image..."
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "Pushing image with both tags..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "‚úÖ Image pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

    - name: Ensure CloudWatch Log Groups Exist
      run: |
        echo "Checking CloudWatch log groups..."
        
        # Create log groups if they don't exist
        aws logs create-log-group --log-group-name $LOG_GROUP --region $AWS_REGION 2>/dev/null || echo "Log group $LOG_GROUP already exists"
        aws logs create-log-group --log-group-name /ecs/portfolio --region $AWS_REGION 2>/dev/null || echo "Log group /ecs/portfolio already exists"
        
        # Set retention policy
        aws logs put-retention-policy --log-group-name $LOG_GROUP --retention-in-days 7 --region $AWS_REGION 2>/dev/null || true
        
        echo "‚úÖ Log groups ready"

    - name: Create task definition from scratch
      env:
        SENDGRID_API_KEY: ${{ secrets.SENDGRID_API_KEY }}
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "Creating task definition..."
        
        # Verify SendGrid key is available
        if [ -z "$SENDGRID_API_KEY" ]; then
          echo "‚ö†Ô∏è WARNING: SENDGRID_API_KEY not set. Email functionality will be disabled."
          SENDGRID_API_KEY="placeholder"
        fi
        
        # Create task definition with correct log group
        cat > task-definition.json << EOF
        {
          "family": "$ECS_TASK_DEFINITION",
          "networkMode": "awsvpc",
          "requiresCompatibilities": ["FARGATE"],
          "cpu": "256",
          "memory": "1024",
          "executionRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID || '257394460825' }}:role/ecsTaskExecutionRole",
          "taskRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID || '257394460825' }}:role/ecsTaskRole",
          "containerDefinitions": [
            {
              "name": "$CONTAINER_NAME",
              "image": "$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG",
              "cpu": 256,
              "memory": 1024,
              "essential": true,
              "portMappings": [
                {
                  "containerPort": 8080,
                  "protocol": "tcp"
                }
              ],
              "environment": [
                {"name": "HR_DEMO_HEALTH_STRATEGY", "value": "actuator-health"},
                {"name": "HR_DEMO_EXTERNAL_URL", "value": "https://demos.somdip.dev"},
                {"name": "HR_DEMO_EMBED_URL", "value": "http://somdip-dev-alb-856223136.us-east-1.elb.amazonaws.com:8081"},
                {"name": "SPRING_PROFILES_ACTIVE", "value": "prod"},
                {"name": "SPRING_MAIL_ENABLED", "value": "true"},
                {"name": "SMTP_HOST", "value": "smtp.sendgrid.net"},
                {"name": "SMTP_PORT", "value": "587"},
                {"name": "SENDGRID_USERNAME", "value": "apikey"},
                {"name": "SENDGRID_API_KEY", "value": "$SENDGRID_API_KEY"}
              ],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-group": "$LOG_GROUP",
                  "awslogs-region": "$AWS_REGION",
                  "awslogs-stream-prefix": "ecs"
                }
              },
              "healthCheck": {
                "command": ["CMD-SHELL", "curl -f http://localhost:8080/actuator/health || exit 1"],
                "interval": 60,
                "timeout": 30,
                "retries": 3,
                "startPeriod": 60
              }
            }
          ]
        }
        EOF
        
        echo "‚úÖ Task definition created"
        cat task-definition.json | jq '.containerDefinitions[0].logConfiguration'

    - name: Register new task definition
      id: register-task-def
      run: |
        echo "Registering new task definition..."
        
        # Register the task definition
        NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
          --cli-input-json file://task-definition.json \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        
        if [ $? -eq 0 ]; then
          echo "new-task-def-arn=$NEW_TASK_DEF_ARN" >> $GITHUB_OUTPUT
          echo "‚úÖ New task definition registered: $NEW_TASK_DEF_ARN"
          
          # Get revision number
          REVISION=$(echo $NEW_TASK_DEF_ARN | awk -F: '{print $NF}')
          echo "üìù New revision: $REVISION"
        else
          echo "‚ùå Failed to register task definition"
          exit 1
        fi

    - name: Update ALB Target Group Health Check
      run: |
        echo "Updating target group health check settings for Spring Boot..."
        
        # Get target group ARN
        TG_ARN="arn:aws:elasticloadbalancing:us-east-1:257394460825:targetgroup/somdip-dev-portfolio/bb80851d2e2ad190"
        
        # Update health check to be more lenient for Spring Boot startup
        aws elbv2 modify-target-group \
          --target-group-arn $TG_ARN \
          --health-check-interval-seconds 60 \
          --health-check-timeout-seconds 50 \
          --unhealthy-threshold-count 3 \
          --healthy-threshold-count 2 || echo "Failed to update health check settings"
        
        echo "‚úÖ Health check settings updated"

    - name: Update ECS service with zero-downtime deployment
      run: |
        echo "Updating ECS service..."
        
        # First, update to single task to ensure smooth deployment
        aws ecs update-service \
          --cluster $ECS_CLUSTER \
          --service $ECS_SERVICE \
          --task-definition ${{ steps.register-task-def.outputs.new-task-def-arn }} \
          --desired-count 1 \
          --health-check-grace-period-seconds 180 \
          --force-new-deployment \
          --deployment-configuration '{
            "minimumHealthyPercent": 0,
            "maximumPercent": 100,
            "deploymentCircuitBreaker": {
              "enable": true,
              "rollback": true
            }
          }' \
          --query 'service.[serviceName,taskDefinition,desiredCount]' \
          --output table
        
        echo "‚úÖ Service update initiated with single task"

    - name: Monitor deployment progress
      run: |
        echo "Monitoring deployment progress..."
        
        # Wait for initial deployment
        DEPLOYMENT_SUCCESS=false
        for i in {1..20}; do
          echo "Check $i/20:"
          
          # Get deployment status
          DEPLOY_STATUS=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --query 'services[0].deployments[0].status' \
            --output text)
          
          RUNNING_COUNT=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --query 'services[0].runningCount' \
            --output text)
          
          echo "  Deployment Status: $DEPLOY_STATUS"
          echo "  Running Tasks: $RUNNING_COUNT"
          
          # Check if the primary deployment is stable
          if [ "$RUNNING_COUNT" -ge 1 ]; then
            # Verify the task is using our new image
            RUNNING_TASK=$(aws ecs list-tasks --cluster $ECS_CLUSTER --service-name $ECS_SERVICE --desired-status RUNNING --query 'taskArns[0]' --output text)
            if [ ! -z "$RUNNING_TASK" ]; then
              TASK_IMAGE=$(aws ecs describe-tasks --cluster $ECS_CLUSTER --tasks $RUNNING_TASK --query 'tasks[0].containers[0].image' --output text)
              echo "  Running image: $TASK_IMAGE"
              
              if [[ "$TASK_IMAGE" == *"${{ github.sha }}"* ]]; then
                echo "‚úÖ New image is running!"
                DEPLOYMENT_SUCCESS=true
                break
              fi
            fi
          fi
          
          sleep 30
        done
        
        if [ "$DEPLOYMENT_SUCCESS" = false ]; then
          echo "‚ùå Deployment failed or timed out"
          aws ecs describe-services --cluster $ECS_CLUSTER --service $ECS_SERVICE --query 'services[0].events[:5]' --output table
          exit 1
        fi

    - name: Scale to desired count
      if: success()
      run: |
        echo "Scaling service to 2 tasks..."
        
        # Now scale to 2 tasks for high availability
        aws ecs update-service \
          --cluster $ECS_CLUSTER \
          --service $ECS_SERVICE \
          --desired-count 2 \
          --deployment-configuration '{
            "minimumHealthyPercent": 100,
            "maximumPercent": 200
          }'
        
        echo "‚úÖ Scaling to 2 tasks initiated"

    - name: Verify final deployment
      run: |
        echo "Final deployment verification..."
        
        # Wait a bit for scaling
        sleep 60
        
        # Get current service details
        echo "Service status:"
        aws ecs describe-services \
          --cluster $ECS_CLUSTER \
          --service $ECS_SERVICE \
          --query 'services[0].[serviceName,taskDefinition,runningCount,desiredCount,deployments[0].status]' \
          --output table
        
        # Verify all tasks are healthy
        echo "Target health status:"
        aws elbv2 describe-target-health \
          --target-group-arn arn:aws:elasticloadbalancing:us-east-1:257394460825:targetgroup/somdip-dev-portfolio/bb80851d2e2ad190 \
          --query 'TargetHealthDescriptions[*].[Target.Id,TargetHealth.State]' \
          --output table

    - name: Test application endpoints
      run: |
        echo "Testing application endpoints..."
        
        # Test main site
        echo "Testing main site:"
        HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://somdip.dev || echo "000")
        echo "  HTTPS Status: $HTTP_STATUS"
        
        # Test ALB directly
        echo "Testing ALB directly:"
        ALB_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "Host: somdip.dev" http://somdip-dev-alb-856223136.us-east-1.elb.amazonaws.com || echo "000")
        echo "  ALB Status: $ALB_STATUS"
        
        if [ "$HTTP_STATUS" = "200" ] || [ "$ALB_STATUS" = "200" ]; then
          echo "‚úÖ Application is responding!"
        else
          echo "‚ö†Ô∏è  Application may still be starting up"
        fi

    - name: Deployment summary
      run: |
        echo ""
        echo "üöÄ Portfolio Deployment Summary"
        echo "==============================="
        echo "‚úÖ New image: ${{ steps.build-image.outputs.image }}"
        echo "‚úÖ Task definition: ${{ steps.register-task-def.outputs.new-task-def-arn }}"
        echo "‚úÖ Service deployment: COMPLETED"
        echo ""
        echo "üîó URLs to test:"
        echo "   Production: https://somdip.dev"
        echo "   ALB Direct: http://somdip-dev-alb-856223136.us-east-1.elb.amazonaws.com"
        echo ""
        echo "üìù Troubleshooting:"
        echo "   - Clear browser cache (Ctrl+F5)"
        echo "   - Test in incognito mode"
        echo "   - Check CloudWatch logs: aws logs tail $LOG_GROUP --follow"
        echo ""
        echo "‚è∞ Note: Spring Boot takes 35-40 seconds to start"

    - name: Cleanup
      run: |
        rm -f task-definition*.json
        echo "‚úÖ Temporary files cleaned up"
